# Covid19 Malware Reverse

## Another way to spread Trickbot by taking advantage of the italian situation

###### `Threat Attack Map`

:::{#container .map-container}

:::{#attackdiv .map-visualize--details-container}
:::

:::
	
###### `Introduction`

**As a very Italian(🇮🇹) responsible person, I'm in self quarantine at the moment**; my country is really struggling with Covid-19 and our President told us to stay at home.

After my last [article](https://medium.com/@antonioblescia/coronavirussafetymeasures-pdf-exe-d14e977bf415) about the reverse engineering of the other Covid19 fake pdf, I decided to reverse another attack that uses a doc to spread a famous malware called **Trickbot**

By Googling I found a lot of articles that talk about an email received from a fake `Dott.sa Penelope Marchetti` that writes from OMS:

![*The fake email*](../assets/images/35fbe4f7-40a7-49ea-a26e-5cca66eaf691.png)

Honestly, the email is written with a wonderful Italian language, this means that the attackers are very interested in targeting Italy by abusing its emergency.

###### `Technical Description`

As next step I need to retrieve the doc sample that is attached to the email; after some search I found it on any.run by using a Google Dork: `"f16744643424.doc" site:any.run`. 

![Sample hashes](../assets/images/38006753-4778-4bf6-82b8-a8cf798d28eb.png)

Once downloaded the sample I analyzed it with [Reaqta](https://reaqta.com/)

![ReaQta infection chain view](../assets/images/88e09662-a392-423b-b6e6-a4945bca4500.png)

As it is possible to see, the document, first creates the folder `C:\MyImages` and puts in it two files, `presskey.cmd` and `presskey.jse`, after runs a cmd.exe session that runs a cscript process as its child. To spawn the process the VBA code doesn't drop any code from the Internet, then, the payloads are stored inside the Macros.

To show the macro's source code, I reopened the doc file, then I clicked on `View->View Macro`

![Macro Document List](../assets/images/7027ae50-8201-47a8-bcbe-0bca5c8ad808.png)

With the macro list, I tried to open the `AutoOpen` macro to see its source code, but.....

![Macro Password](../assets/images/b70e1e7a-47e5-4a34-a9fa-46b4a086c981.png)

Word requested me a password! To bypass the protection I changed the DPB parameters declared inside the `VBAProject.bin` file and unlock the macro protection.

![Macro Locking Protection](../assets/images/6b067614-ffc4-4053-87c0-6fd3585dcba2.png)

As I said before, the source code of the two files inside the `MyImages` folder was declared inside the Macro, in fact, I saw it inside the `maximepixsc` macro function

![Macro Binary Stream to files](../assets/images/c2685b78-8dd4-4eef-b21f-38bd78d9fdc1.png)

Once obtained the macro source code I passed to analyze the two files inside the `MyImages` folder. The first file, `presskey.cmd` is used only to run `cscript.exe` by passing the `presskey.jse` file as argument. This file is very obfuscated and its structure rembembers me a classic Trickbot dropper.

![Classic Trickbot Dropper Obfuscation Indicator](../assets/images/4a1f0bb2-f4ef-42d6-b09c-f7cdd63fb601.png)

The script has the most common anti-analysis tricks: obfuscation, anonymous functions, dynamic sleeps, and so on.

When I saw the session on any.run I didn't see any communication with external servers. This is a common sandbox evasion implementation to make impossible a dynamic analysis on free malware hunting platforms.

For this reason I decided to debug the code on my physical machine with Visual Studio 2019. To debug a **js Windows Host Script** it is necessary to configure the VS with the external debug tool(I will write a brief article to achieve this goal).

After the Visual Studio configuration step, I renamed the extension file from `*.jse` to `*.js` and I lunched the `cscript.exe //X keypress.js` command.

With the debug attached to cscript instance, I declared different global variables to follow the code execution step by step. The attacker delays the infection step by using a while condition with a dynamic threshold value.

![Dynamic Delay implemented with while loop costruct](../assets/images/f88ca7c8-ac13-4b92-9bfe-053406b63e18.png)

To accelerate the infection process, I modified the variable `sbhKVhome66` value to make true the if condition and I saw that the script made a different environment check, like the installed Hard Drives

![Hard Drives Enumeration](../assets/images/9dec2ef2-87b5-40e7-9995-a506d7c4feff.png)

After the checks, the script contacted the backend to download the Trickbot malware

![Trickbot downloading](../assets/images/fe423858-43ef-4223-970b-a14d99f0079e.png)

![ProcMon Network Analysis](../assets/images/91031ccc-1eab-4776-b015-6b2ed46dbe6c.png)

![Whois IP](../assets/images/fc464042-36f4-46af-9aab-42ced43add70.png)

###### `Update`

After some days of observation I saw an unusual chain infection. Typically an infected document drops `Emotet` to creates the persistence and, after, `Emotet` drops `Trickbot` to steal sensitive data.

In this infection, the situation is inverted, `Trickbot` drops `Emotet`. The attackers, probably, have as first goal steal sensitive information and after sell the access on the dark web.

Tipically, this type of infection chain leads to a ransomware infection like `Ryuk`

![Ryuk, the protagonist of Death Note](../assets/images/fffe39cf-b830-4282-bd14-4cb908fa93a1.jpg)

Once started the `Emotet` infection, I ran `Wireshark` to capture the http request sent to `Emotet` C2. Every request is sent using clear `HTTP` without the `TLS` support, but, the request body is encrypted. 

![Wireshark capture](../assets/images/1975608f-6bd0-4b43-83f7-2f928bfcfcac.png)

With the encrypted body, I decided to debug the obfuscated `Emotet` code by hooking the Win32 Api to see what type of data are sent to the C2.

The hooking techniques consists of inject a custom `dll` inside a process. This dll contains a code that intercept all of user-space calls module and print the passed parameter by the process.

Below what I found by hooking the `Emotet` process.

![CryptExportKey Win32Api Call](../assets/images/a384314d-49f7-4597-b99b-bdd82fca226b.png)

Emotet, first, requests to the Windows `CSP` (Cryptography Service Provider) the key pair

![CryptStringToBinaryA Win32 Api Call](../assets/images/2a399541-2a21-4693-9887-dbc8e3d69bf2.png)

Loads the symmetric key with `base64` encoding;

![CryptStringToBinaryA Win32 Api Call](../assets/images/4bbbc800-4209-45ed-bc97-562e3067e0cf.png)

After, loads the asymmetric public key used to encrypt the communication with the C2.

![Processes enumertion](../assets/images/d27fb789-5d8b-49a5-b538-998c03d5310a.png)

Enumerates the running processes, probably to detect if the running environment is a Virtual Machine.

![CryptEncrypt Win32 Api Call](../assets/images/e679de2-0b9c-4968-acc9-0b2b6a1f09af.png)

Encrypts the processes list payload with CryptEncrypt Win32 Api

![HTTP Request](../assets/images/03de8bc8-05c2-4b3a-93ca-53249676d47f.png)

Sends the encrypted payload to the C2 by encapsulating it inside an HTTP request

![HTTP Response](../assets/images/7b68baaa-57ba-4280-bdf8-a82fab5edf07.png)

Finally, receives the response from the `Emotet` C2.

###### `Conclusion`

The `thread map`, on top of this article, shows the real connections made during the process infection(from the document to Emotet)

I think that this is a classic type of infection, as I said before, that leads to a ransomware attack.

###### `IoC`

You can find [here](https://gist.github.com/nocommentlab/d9d815ecfd88fb1e487948c318d5b435) the extracted IoC.





